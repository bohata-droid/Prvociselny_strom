<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Factor Tree – krokové rozklikávání</title>
  <style>
    :root{
      --bg:#0b1220;
      --ink:#e9eefc;
      --muted:#a9b6da;
      --accent:#79a6ff;
      --good:#47d18c;
      --warn:#ffcc66;
      --bad:#ff6b6b;
      --stroke:#2a3a63;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(900px 520px at 30% 0%, #122047 0%, var(--bg) 60%);
      color:var(--ink);
    }

    header{
      padding:12px 12px 10px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      background: rgba(16,26,47,0.65);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .headerInner{ position: relative; }

    h1{ margin:0 0 6px 0; font-size:15px; font-weight:900; letter-spacing:0.2px; }
    .sub{ margin:0; font-size:12.5px; color:var(--muted); line-height:1.35; }

    .bar{
      margin-top:10px;
      display:grid;
      grid-template-columns: auto 1fr auto;
      gap:8px;
      align-items:center;
    }

    .pill{
      font-size:12px; color:var(--muted);
      border:1px solid rgba(255,255,255,0.10);
      padding:7px 10px; border-radius:999px;
      background: rgba(16,26,47,0.35);
      white-space:nowrap;
    }

    button{
      background: linear-gradient(180deg, #1a2b55 0%, #132244 100%);
      color:var(--ink);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      padding:9px 10px;
      cursor:pointer;
      font-weight:800;
      font-size:12.5px;
      user-select:none;
    }
    button:active{ transform: translateY(1px); }
    .ghost{ background: transparent; border-color: rgba(255,255,255,0.14); }

    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(16,26,47,0.35);
      color:var(--muted);
      font-size:12px;
      font-weight:800;
      user-select:none;
      white-space:nowrap;
    }
    .toggle input{
      width:42px;
      height:24px;
      appearance:none;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:999px;
      position:relative;
      outline:none;
      cursor:pointer;
    }
    .toggle input::after{
      content:"";
      position:absolute;
      top:2px; left:2px;
      width:18px; height:18px;
      border-radius:50%;
      background: rgba(233,238,252,0.9);
      transition: transform .18s ease;
    }
    .toggle input:checked{
      background: rgba(121,166,255,0.25);
      border-color: rgba(121,166,255,0.45);
    }
    .toggle input:checked::after{ transform: translateX(18px); }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    /* PC overlay result: centered in whole header, full height */
    #pcResultOverlay{
      position:absolute;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 1;
    }
    #pcResultOverlay .box{
      height: 100%;
      display:flex;
      align-items:center;
      justify-content:center;
      width: min(980px, calc(100% - 16px));
      margin: 0 auto;
      padding: 0 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(11,18,32,0.45);
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
      text-align:center;
      font-weight: 950;
      letter-spacing: 0.2px;
      line-height: 1.05;
      color: var(--ink);
    }
    #pcResultOverlay .prime{ color: var(--good); }
    #pcResultOverlay .sep{ color: var(--muted); font-weight: 900; }

    .headerLayer{ position: relative; z-index: 2; }

    main{ padding:10px 10px 26px; }
    .stage{
      background: rgba(16,26,47,0.55);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:18px;
      padding:10px;
      overflow:hidden;
    }

    /* Mobile default */
    svg{ width:100%; height: min(72vh, 860px); display:block; touch-action: manipulation; }

    /* PC mode: more vertical space */
    body.pc svg{ height: min(82vh, 1040px); }
  </style>
</head>
<body>
  <header>
    <div class="headerInner">
      <div id="pcResultOverlay" aria-live="polite">
        <div class="box" id="pcResultText"></div>
      </div>

      <div class="headerLayer">
        <h1>Strom rozkladu na prvočísla</h1>
        <p class="sub">Klikněte na složené číslo → vyplňte činitele → potvrďte Enterem (nebo klepněte mimo).</p>

        <div class="bar">
          <span class="pill" id="targetPill"></span>
          <div></div>
          <div class="controls">
            <label class="toggle" title="Zvětší vykreslení pro PC / projektor">
              malé/velké
              <input id="pcToggle" type="checkbox" />
            </label>
            <button id="customBtn" class="ghost">Vlastní číslo</button>
            <button id="newBtn">Nové číslo</button>
            <button id="resetBtn" class="ghost">Reset</button>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="stage">
      <svg id="svg" viewBox="0 0 360 720" xmlns="http://www.w3.org/2000/svg" aria-label="Factor tree"></svg>
    </div>
  </main>

<script>
(() => {
  // ---------- Math ----------
  function isPrime(n){
    n = Math.trunc(n);
    if(n <= 1) return false;
    if(n <= 3) return true;
    if(n % 2 === 0 || n % 3 === 0) return false;
    for(let i=5; i*i<=n; i+=6){
      if(n % i === 0 || n % (i+2) === 0) return false;
    }
    return true;
  }
  function isComposite(n){
    return Number.isInteger(n) && n >= 4 && !isPrime(n);
  }
  function randomCompositeUnder200(){
    while(true){
      const n = 4 + Math.floor(Math.random() * (199 - 4 + 1));
      if(isComposite(n)) return n;
    }
  }

  // ---------- PC mode / scaling ----------
  const PC_SCALE = 2.0;
  const SCALE_KEY = "factorTreePcMode";
  const pcToggle = document.getElementById("pcToggle");
  let pcMode = localStorage.getItem(SCALE_KEY) === "1";
  pcToggle.checked = pcMode;

  function setBodyClass(){
    document.body.classList.toggle("pc", pcMode);
  }
  setBodyClass();

  function scaleVal(v){ return pcMode ? v * PC_SCALE : v; }

  // Minimum readability: 11pt ≈ 14.67px
  const MIN_READABLE_PX = 15;

  // ---------- Header PC overlay ----------
  const pcResultOverlay = document.getElementById("pcResultOverlay");
  const pcResultText = document.getElementById("pcResultText");
  function showPcOverlay(html, fontPx){
    pcResultText.style.fontSize = fontPx + "px";
    pcResultText.innerHTML = html;
    pcResultOverlay.style.display = "flex";
  }
  function hidePcOverlay(){
    pcResultOverlay.style.display = "none";
    pcResultText.textContent = "";
  }

  // ---------- Model ----------
  let idSeq = 1;
  function makeNodeValue(n){
    return { id:idSeq++, value:n, inputStr:null, left:null, right:null, expanded:false, pendingPair:false, _bad:false };
  }
  function makeNodeInput(){
    return { id:idSeq++, value:null, inputStr:"", left:null, right:null, expanded:false, pendingPair:false, _bad:false };
  }

  function isVisibleLeaf(node){
    return !node.expanded || (!node.left && !node.right);
  }
  function visibleLeaves(node, out=[]){
    if(!node) return out;
    if(isVisibleLeaf(node)) out.push(node);
    else { visibleLeaves(node.left, out); visibleLeaves(node.right, out); }
    return out;
  }
  function walkVisible(node, fn){
    if(!node) return;
    fn(node);
    if(node.expanded){
      walkVisible(node.left, fn);
      walkVisible(node.right, fn);
    }
  }
  function isDone(root){
    const lf = visibleLeaves(root);
    if(lf.some(n => n.value === null)) return false;
    if(lf.some(n => n.value !== null && !isPrime(n.value))) return false;
    return true;
  }

  // ---------- Layout ----------
  function computeLayout(root, W, rHalo){
    const leafList = visibleLeaves(root);
    const leafIndex = new Map();
    leafList.forEach((n, i) => leafIndex.set(n.id, i));

    const margin = scaleVal(20);

    // shorter vertical spacing
    const yGap = scaleVal(105);

    // root near top (so it can "go up" naturally as the tree grows)
    const rootY = scaleVal(70);

    // enforce minimum horizontal gap in PC so circles never overlap
    const minGap = pcMode ? (2 * rHalo + scaleVal(24)) : 0;

    const usableBase = W - margin*2;
    const xGapBase = leafList.length <= 1 ? 0 : usableBase / (leafList.length - 1);

    // slightly wider even on mobile; on PC also enforce minGap
    const xGap = pcMode ? Math.max(xGapBase * 1.10, minGap) : (xGapBase * 1.06);

    const pos = new Map();
    function assign(node, d){
      if(isVisibleLeaf(node)){
        const i = leafIndex.get(node.id) ?? 0;
        const x = margin + i * xGap;
        const y = rootY + d * yGap;
        pos.set(node.id, { x, y, d });
        return pos.get(node.id);
      } else {
        const L = assign(node.left, d+1);
        const R = assign(node.right, d+1);
        const x = (L.x + R.x) / 2;
        const y = rootY + d * yGap;
        pos.set(node.id, { x, y, d });
        return pos.get(node.id);
      }
    }
    assign(root, 0);
    return pos;
  }

  // ---------- SVG helpers ----------
  const svg = document.getElementById('svg');
  function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
  function el(name, attrs={}, children=[]){
    const e = document.createElementNS("http://www.w3.org/2000/svg", name);
    for(const [k,v] of Object.entries(attrs)) e.setAttribute(k, String(v));
    for(const c of children) e.appendChild(c);
    return e;
  }

  function nodeStyle(node){
    if(node.value === null){
      return {
        fill: "rgba(121,166,255,0.08)",
        stroke: node._bad ? "rgba(255,107,107,0.75)" : "rgba(121,166,255,0.38)",
        text: "rgba(233,238,252,0.92)"
      };
    }
    if(isPrime(node.value)){
      return {
        fill: "rgba(71,209,140,0.18)",
        stroke: "rgba(71,209,140,0.78)",
        text: "rgba(233,238,252,0.95)"
      };
    }
    return {
      fill: "rgba(255,204,102,0.12)",
      stroke: "rgba(255,204,102,0.70)",
      text: "rgba(233,238,252,0.95)"
    };
  }

  // ---------- Expansion / confirmation ----------
  function ensureChildren(node){
    if(node.value === null) return false;
    if(isPrime(node.value)) return false;
    if(node.left && node.right) return true;
    node.left = makeNodeInput();
    node.right = makeNodeInput();
    node.pendingPair = true;
    return true;
  }
  function findParent(root, child){
    let parent = null;
    walkVisible(root, (n) => { if(n.left === child || n.right === child) parent = n; });
    return parent;
  }
  function commitTryConfirm(parent){
    if(!parent || !parent.pendingPair) return false;

    const aStr = parent.left?.inputStr ?? "";
    const bStr = parent.right?.inputStr ?? "";
    if(aStr === "" || bStr === "") return false;

    const a = Number(aStr);
    const b = Number(bStr);

    const ok =
      Number.isInteger(a) && Number.isInteger(b) &&
      a > 1 && b > 1 &&
      a * b === parent.value;

    if(ok){
      parent.left.value = a; parent.left.inputStr = null; parent.left._bad = false;
      parent.right.value = b; parent.right.inputStr = null; parent.right._bad = false;
      parent.pendingPair = false;
      return true;
    } else {
      parent.left._bad = true;
      parent.right._bad = true;
      return true;
    }
  }
  function sanitizeDigits(s){
    return (s ?? "").replace(/[^\d]/g, "").slice(0, 3);
  }

  // ---------- Result builders ----------
  function getPrimesSorted(root){
    return visibleLeaves(root).map(n => n.value).sort((a,b)=>a-b);
  }
  function buildPcOverlayHtml(root, target){
    const primes = getPrimesSorted(root);
    const parts = [];
    parts.push(`<span>${target} = </span>`);
    primes.forEach((p, i) => {
      parts.push(`<span class="prime">${p}</span>`);
      if(i < primes.length - 1) parts.push(`<span class="sep"> · </span>`);
    });
    return parts.join("");
  }

  // Mobile: inside SVG under tree
  function drawFactorizationBoxMobile(root, target, pos, gContent){
    let maxY = 0;
    walkVisible(root, (n) => {
      const p = pos.get(n.id);
      if(p) maxY = Math.max(maxY, p.y);
    });

    const vb = svg.viewBox.baseVal;
    const W = vb.width || 360;
    const H = vb.height || 720;

    const boxW = Math.min(320, W - 20);
    const boxH = 52;
    const gap  = 56;

    let y = maxY + gap;
    y = Math.min(y, H - boxH - 12);
    const x = (W - boxW) / 2;

    const primes = getPrimesSorted(root);

    gContent.appendChild(el("rect", {
      x, y, width: boxW, height: boxH, rx: 14, ry: 14,
      fill: "rgba(11,18,32,0.55)",
      stroke: "rgba(255,255,255,0.12)",
      "stroke-width": 1
    }));

    const text = el("text", {
      x: W/2, y: y + boxH*0.66,
      "text-anchor":"middle",
      "font-size": "16",
      "font-weight":"950",
      fill:"rgba(233,238,252,0.95)"
    });

    const t0 = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    t0.textContent = `${target} = `;
    text.appendChild(t0);

    primes.forEach((p, i) => {
      const tp = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      tp.textContent = String(p);
      tp.setAttribute("fill", "rgba(71,209,140,0.95)");
      text.appendChild(tp);

      if(i < primes.length - 1){
        const sep = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        sep.textContent = " · ";
        sep.setAttribute("fill", "rgba(169,182,218,0.95)");
        text.appendChild(sep);
      }
    });

    gContent.appendChild(text);
  }

  // ---------- PC auto-fit with minimum readable size ----------
  function applyAutoFitIfNeeded(root, pos, rHalo, gContent, baseTextPx){
    if(!pcMode){
      gContent.setAttribute("transform", "");
      return;
    }

    const vb = svg.viewBox.baseVal;
    const W = vb.width || 360;
    const H = vb.height || 720;
    const pad = 10;

    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    walkVisible(root, (n) => {
      const p = pos.get(n.id);
      if(!p) return;
      minX = Math.min(minX, p.x - rHalo);
      maxX = Math.max(maxX, p.x + rHalo);
      minY = Math.min(minY, p.y - rHalo);
      maxY = Math.max(maxY, p.y + rHalo);
    });
    if(!Number.isFinite(minX)) return;

    const extW = Math.max(1, maxX - minX);
    const extH = Math.max(1, maxY - minY);

    const availW = W - pad*2;
    const availH = H - pad*2;

    let sFit = Math.min(1, availW / extW, availH / extH);

    const minScaleForText = MIN_READABLE_PX / Math.max(1, baseTextPx);
    const s = Math.max(sFit, minScaleForText);

    const tx = pad + (availW - extW * s) / 2 - minX * s;

    // top anchored: root naturally goes "up" as tree grows
    const ty = pad - minY * s;

    gContent.setAttribute("transform", `translate(${tx.toFixed(3)},${ty.toFixed(3)}) scale(${s.toFixed(4)})`);
  }

  // Focus after expand
  let focusNodeId = null;

  // ---------- Draw tree ----------
  function drawTree(root){
    clearSVG();

    const vb = svg.viewBox.baseVal;
    const W = vb.width || 360;

    const rNode = scaleVal(28);
    const rHalo = scaleVal(34);
    const edgeW = scaleVal(3);

    // Base size before auto-fit scaling
    const textSize = scaleVal(18);
    const baseTextPx = textSize;

    const foW = scaleVal(48);
    const foH = scaleVal(36);
    const inpFont = scaleVal(14);
    const inpRadius = scaleVal(12);

    const pos = computeLayout(root, W, rHalo);

    const gContent = el("g", { id: "content" });
    svg.appendChild(gContent);

    function drawEdges(node){
      if(!node || !node.expanded || isVisibleLeaf(node)) return;
      const p = pos.get(node.id);
      const l = pos.get(node.left.id);
      const r = pos.get(node.right.id);

      // shorter ends so "větve" působí kratší
      const endGap = scaleVal(7);

      const mk = (a,b) => el("line", {
        x1:a.x, y1:a.y + (rNode - endGap),
        x2:b.x, y2:b.y - (rNode - endGap),
        stroke:"rgba(42,58,99,0.95)",
        "stroke-width": edgeW,
        "stroke-linecap":"round"
      });

      gContent.appendChild(mk(p,l));
      gContent.appendChild(mk(p,r));
      drawEdges(node.left);
      drawEdges(node.right);
    }

    function drawNodes(node){
      if(!node) return;
      const p = pos.get(node.id);
      const st = nodeStyle(node);
      const clickableExpand = (node.value !== null && !isPrime(node.value) && !node.expanded);

      const g = el("g", {"data-id": node.id});

      const halo = el("circle", {
        cx:p.x, cy:p.y, r:rHalo,
        fill: clickableExpand ? "rgba(121,166,255,0.10)" : "transparent",
        stroke: clickableExpand ? "rgba(121,166,255,0.35)" : "transparent",
        "stroke-width": clickableExpand ? scaleVal(2) : 0
      });

      const circle = el("circle", {
        cx:p.x, cy:p.y, r:rNode,
        fill: st.fill,
        stroke: st.stroke,
        "stroke-width": scaleVal(3)
      });

      g.appendChild(halo);
      g.appendChild(circle);

      if(node.value !== null){
        const t = el("text", {
          x:p.x, y:p.y+(textSize*0.33),
          "text-anchor":"middle",
          "font-size": String(textSize),
          "font-weight":"950",
          fill: st.text
        });
        t.textContent = node.value;
        g.appendChild(t);
      } else {
        const fo = el("foreignObject", { x: p.x-foW/2, y: p.y-foH/2, width: foW, height: foH });
        const inp = document.createElement("input");
        inp.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
        inp.type = "text";
        inp.inputMode = "numeric";
        inp.autocomplete = "off";
        inp.value = node.inputStr ?? "";
        inp.dataset.nodeId = String(node.id);

        inp.style.cssText = `
          width:${foW}px;height:${foH}px;
          border-radius:${inpRadius}px;
          border:1px solid ${node._bad ? "rgba(255,107,107,0.75)" : "rgba(255,255,255,0.14)"};
          background: rgba(16,26,47,0.55);
          color: var(--ink);
          font-weight:950;
          font-size:${inpFont}px;
          text-align:center;
          outline:none;
        `;

        inp.addEventListener("input", () => {
          node._bad = false;
          const cleaned = sanitizeDigits(inp.value);
          if(inp.value !== cleaned) inp.value = cleaned;
          node.inputStr = cleaned;

          const parent = findParent(root, node);
          if(parent){
            parent.left && (parent.left._bad = false);
            parent.right && (parent.right._bad = false);
          }
        });

        const commit = () => {
          const parent = findParent(root, node);
          if(parent){
            const shouldRedraw = commitTryConfirm(parent);
            if(shouldRedraw) drawTree(root);
          }
        };

        inp.addEventListener("keydown", (e) => {
          if(e.key === "Enter"){
            e.preventDefault();
            commit();
          }
        });
        inp.addEventListener("blur", () => { commit(); });

        fo.appendChild(inp);
        g.appendChild(fo);
      }

      if(clickableExpand){
        g.style.cursor = "pointer";
        g.addEventListener("click", (ev) => {
          ev.stopPropagation();
          ensureChildren(node);
          node.expanded = true;
          focusNodeId = node.left?.id ?? null;
          drawTree(root);
        });
      }

      gContent.appendChild(g);

      if(node.expanded){
        drawNodes(node.left);
        drawNodes(node.right);
      }
    }

    drawEdges(root);
    drawNodes(root);

    if(isDone(root)){
      if(pcMode){
        const html = buildPcOverlayHtml(root, target);
        const overlayFontPx = Math.max(18, scaleVal(18));
        showPcOverlay(html, Math.round(overlayFontPx));
      } else {
        hidePcOverlay();
        drawFactorizationBoxMobile(root, target, pos, gContent);
      }
    } else {
      hidePcOverlay();
    }

    applyAutoFitIfNeeded(root, pos, rHalo, gContent, baseTextPx);

    if(focusNodeId !== null){
      const inp = svg.querySelector(`input[data-node-id="${focusNodeId}"]`);
      if(inp){
        requestAnimationFrame(() => { try { inp.focus(); } catch(_){} });
      }
      focusNodeId = null;
    }
  }

  // ---------- App state ----------
  const targetPill = document.getElementById('targetPill');
  const newBtn = document.getElementById('newBtn');
  const resetBtn = document.getElementById('resetBtn');
  const customBtn = document.getElementById('customBtn');

  let target = randomCompositeUnder200();
  let root = makeNodeValue(target);

  function updateTargetUI(){ targetPill.textContent = `Číslo: ${target}`; }

  function setNewTarget(n){
    target = n;
    root = makeNodeValue(target);
    updateTargetUI();
    hidePcOverlay();
    drawTree(root);
  }

  function newNumber(){ setNewTarget(randomCompositeUnder200()); }
  function resetTree(){ root = makeNodeValue(target); hidePcOverlay(); drawTree(root); }

  function askCustom(){
    const raw = prompt("Zadej složené číslo 4–199:", String(target));
    if(raw === null) return;
    const n = Number(String(raw).trim());
    if(!Number.isInteger(n) || n < 4 || n > 199){
      alert("Zadej celé číslo v rozsahu 4–199.");
      return;
    }
    if(isPrime(n)){
      alert("Tohle je prvočíslo. Zadej složené číslo.");
      return;
    }
    setNewTarget(n);
  }

  newBtn.addEventListener("click", newNumber);
  resetBtn.addEventListener("click", resetTree);
  customBtn.addEventListener("click", askCustom);

  pcToggle.addEventListener("change", () => {
    pcMode = pcToggle.checked;
    localStorage.setItem(SCALE_KEY, pcMode ? "1" : "0");
    setBodyClass();
    drawTree(root);
  });

  // ---------- FIX: resize handler that won't kill mobile keyboard ----------
  let resizeTimer = null;
  window.addEventListener("resize", () => {
    // If user is typing into a node input, DO NOT redraw (mobile keyboard would close)
    const ae = document.activeElement;
    const typingInNodeInput =
      ae && ae.tagName === "INPUT" && ae.dataset && "nodeId" in ae.dataset;

    if(typingInNodeInput) return;

    // PC mode benefits from redraw (auto-fit); mobile usually doesn't need it.
    if(!pcMode){
      // On mobile: only redraw after a small debounce (e.g., rotation), not on keyboard show/hide.
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        const ae2 = document.activeElement;
        const stillTyping =
          ae2 && ae2.tagName === "INPUT" && ae2.dataset && "nodeId" in ae2.dataset;
        if(!stillTyping) drawTree(root);
      }, 250);
      return;
    }

    // PC: redraw (debounced) for projector/window resize
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => drawTree(root), 80);
  }, { passive:true });

  // ---------- Init ----------
  updateTargetUI();
  drawTree(root);
})();
</script>
</body>
</html>

